{"name":"rest","qualifiedName":"rest/rest","comment":"","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{}},"classes":{"class":[{"name":"Rest","qualifiedName":"rest/rest.Rest","preview":"<p>A REST server.</p>"},{"name":"RestResponse","qualifiedName":"rest/rest.RestResponse","preview":"<p>A response to a REST request.</p>"},{"name":"RestRoute","qualifiedName":"rest/rest.RestRoute","preview":"<p>A REST route using available methods.</p>"},{"name":"Router","qualifiedName":"rest/rest.Router","preview":"<p>A route manager for resolving URLs to functional endpoints.</p>"},{"name":"Verb","qualifiedName":"rest/rest.Verb","preview":"<p>A REST verb handler for a request route.</p>"}],"typedef":{},"error":[{"name":"NoSuchVerbException","qualifiedName":"rest/rest.NoSuchVerbException","preview":"<p>Exception when defining verb mappings for nonexistent methods.</p>"},{"name":"RouteNotFoundException","qualifiedName":"rest/rest.RouteNotFoundException","preview":"<p>Exception when no route is found.</p>"}]},"packageName":"rest","packageIntro":"<h1>rest</h1>\n<p>This Dart library provides two things:</p><ul><li>an HTTP REST server implementation</li><li>extensible, generic REST implementation for building REST-ful applications</li></ul>\n<h2>Installing</h2>\n<p>Add \"rest\" as a dependency in your <strong>pubspec.yaml</strong> file, and run <code>pub\ninstall</code>.</p>\n<p>More information: https://www.dartlang.org/tools/pub/get-started.html#installing-packages</p>\n<h2>Usage</h2>\n<p>Within <code>dart:io HttpServer</code>, instantiate and resolve REST-ful requests by\ncreating an <code>HttpRest</code> handler. The <code>HttpRest</code> handler itself is instantiated\nby a route map that you generate and provide, with endpoints that you generate\nand provide.</p>\n<p>Generally, this involves four steps.</p><ul><li>Firstly; importing the library.</li></ul>\n<pre class=\"dart\"><code>        import 'rest:rest/http_rest.dart' show\n          HttpRest, HttpRestRoute, HttpRestResponse, RouteNotFoundException;\n</code></pre><ul><li>Secondly; building the routes.</li></ul>\n<pre class=\"dart\"><code>      // keys are regular expressions\n\n      var routes = {\n        r\"^foo\": {\n          r\"^bar$\": new HttpRestRoute({\n            'GET': fooBar   // a function called fooBar\n          }),\n          r\"^bat$\": new HttpRestRoute({\n            'POST': fooBat  // a function called fooBat\n          })\n        }\n      }\n\n      HttpRest rest = new HttpRest(routes);\n</code></pre><ul><li>Thirdly; creating the server and adding the resolve action.</li></ul>\n<pre class=\"dart\"><code>      HttpServer.bind('0.0.0.0', 8000),then((server) {\n        server.listen((HttpRequest request)\n          try {\n\n            // HttpRest will write and close the response to the request\n            // if it finds a useable endpoint\n\n            rest.resolve(request);\n\n          } on RouteNotFoundException {\n\n            // rest.resolve through an exception because it couldn't find\n            // and endpoint with the url\n\n            request.response.close();\n\n          }\n        });\n      });\n</code></pre><ul><li>Fourthly; defining your end-point functions.</li></ul>\n<pre class=\"dart\"><code>      fooBar() {\n        return new HttpRestResponse().build(200, 'fooBar!\\n');\n      }\n\n      fooBat() {\n        return new HttpRestResponse().build(502, 'fooBat!\\n');\n      }\n</code></pre>\n<p>See <code>example/example-rest.dart</code> for a more in-depth, working example.</p>\n<h3>On Endpoint Functions</h3>\n<p>Notice that the examples above are building <code>HttpRestResponse</code> objects.\nYour endpoint functions can;</p><ul><li>also do this,</li></ul>\n<pre class=\"dart\"><code>        myEndpoint() { return new HttpRestResponse().build(\n          200, \"stuff and things\\n\"); }\n</code></pre><ul><li>\n<p>return a <code>Map</code> with associated fields that will automatically build an\n<code>HttpRestResponse</code> object for you,</p></li></ul>\n<pre class=\"dart\"><code>        myEndPoint() { return { 'code': 200, 'body': \"stuff and things\\n\" }; }\n</code></pre><ul><li>\n<p>or return anything else, in which case the return object's <code>.toString()</code>\nmethod is used to generate the body and the response code is set to <code>200</code></p></li></ul>\n<pre class=\"dart\"><code>        myEndPoint() { return \"stuff and things\\n\"; }\n</code></pre>\n<h2>Extending REST</h2>\n<p>Extensible classes exist to create your own REST interfaces, HTTP based or\notherwise. Doing so is a matter of defining what verbs you want to use.</p>\n<pre class=\"dart\"><code>    import \"package:rest/rest.dart\" show Rest, RestRoute;\n\n    class YodaRest implements Rest {\n      // ...\n    }\n\n    class YodaRestRoute extends RestRoute {\n\n      Map&lt;String,Verb&gt; verbs = {\n        'DO':     null,\n        'DO_NOT': null,\n        'TRY':    throw new Exception('There is no try!')\n      }\n\n      // ...\n    }\n</code></pre>\n<p>And etcetera.</p>\n<h2>Development</h2>\n<p>This project is currently functional, but in need of heavy development.</p>\n<p>https://github.com/spacez320/dart-rest</p>\n<p>If you would like to see continued development on this library, have\nsuggestions, or would like to contribute; please feel free to file pull\nrequests or contact me directly (through Github).</p>\n<h2>Documentation</h2>\n<p>API docs are generated and available on pub.dartlang.org.</p>\n<p>http://pub.dartlang.org/packages/rest</p>\n<h2>Copyright/Licensing</h2>\n<p>See LICENSE</p>"}